fitmodelCl <- function(x, model, count, nRand = 999, nCores = 2, ...){
  if(!(model %in%  c("dominanceDecay", "dominancePreemp", "MacArthurFraction", 
                     "powerFraction", "randAssort", "randFraction"))){
    stop(paste("\n'model' must be one of this:", '"dominanceDecay", "dominancePreemp", "MacArthurFraction", "powerFraction", "randAssort", "randFraction"'))
  }
  
  if(!is.matrix(x) & !is.data.frame(x)){
    stop("\n'x' must be a data frame or a matrix")
  }
  
  if(length(x[ ,1]) < 2){
    stop("\nYou must have more than one replicates in lines")
  }
  
  if(is.null(count)){
    stop("\n'count' must be specified")
  }
  
  # Detect numbers of cores and make a cluster
  nc <- detectCores()
  if(nc < 2) {
    stop("You must have at least 2 cores to use 'fitmodelCl'. Use command 'fitmodel'")
  } else {
    if(nCores > nc){
      stop(paste("You informed more cores than detected.", "Detected", nc, "cores"))
    } else {
      if(nCores != 1){
        nc <- nCores
      }
    }
  }
  cl <- makeCluster(nc)
  
  # It partitions randomizations between cores
  randc <- rep(floor(nRand / nc), nc)
  if(sum(randc < nRand)){
    randc[1:(nRand - sum(randc))] <- randc[1:(nRand - sum(randc))] + 1
  }
  
  # Number of replicates and total species
  n <- dim(x)[1]
  S <- dim(x)[2]
  # Total abundance of each replicates.
  N <- apply(x, MARGIN = 1, FUN = sum)
  
  # Function to run in each cores
  fn <- function(rand, n, N, S, model, count, ...){
    clM <- matrix(nrow = rand, ncol = S)
    clV <- matrix(nrow = rand, ncol = S)
    for(i in 1:rand){
      sim <- matrix(nrow = n, ncol = S)
      for(j in 1:n){
        sim[j, ] <- model(N = N[j], S = S, count = count, ...)
        # Transform to relative abundance
        sim[j, ] <- sim[j, ] / sum(sim[j, ])
      }
      clM[i, ] = apply(sim, MARGIN = 2, FUN = mean)
      clV[i, ] = apply(sim, MARGIN = 2, FUN = var)
    }
    return(list(M = clM, V = clV))
  }
  
  # Send function to cluster
  tmp <- clusterApplyLB(cl, randc, fn, n = n, N = N, S = S, model = getFunction(model), count = count, ...)

  # 'nRand' means and variances of 'n' simulations to the model.
  M <- matrix(ncol = S)
  V <- matrix(ncol = S)
  
  # Create data frame with result of cluster
  M <- tmp[[1]]$M
  V <- tmp[[1]]$V
  for(i in 2:length(tmp)){
    M <- rbind(M, tmp[[i]]$M)
    V <- rbind(V, tmp[[i]]$V)
  }
  
  # Recycling objects names
  rm(fn, tmp)
  
  # Transform each replicate to relative abundance.
  for(i in 1:n){
    x[i, ] <- sort(x[i, ] / sum(x[i, ]), decreasing = TRUE)
  }
  
  # Observed relative abundance mean and variance of replicates.
  M0 <- apply(x, MARGIN = 2, FUN = mean)
  V0 <- apply(x, MARGIN = 2, FUN = var)
  
  # Probability that the observed mean and variance are predicted by the model.
  pM0 <- c()
  pV0 <- c()
  for(i in 1:S){
    # p = (b+1)/(m+1)
    pM0[i] <- 2 * min((sum(M[ ,i] < M0[i]) + 1) / (nRand + 1),
                      (sum(M[ ,i] > M0[i]) + 1) / (nRand + 1))
    pV0[i] <- 2 * min((sum(V[ ,i] < V0[i]) + 1) / (nRand + 1),
                      (sum(V[ ,i] > V0[i]) + 1) / (nRand + 1))
  }
  
  # Global statistic (T observed) to combined p of all ranks.
  TM0 <- -2 * sum(log(pM0))
  TV0 <- -2 * sum(log(pV0))
  
  # Function to run in cluster
  fn <- function(core, rand, nRand, M, V, S){
    cldTM <- c()
    cldTV <- c()
    
    if(core == 1){
      range <- 1:rand[1]
    } else{
      range <- (sum(rand[1:(core - 1)]) + 1):sum(rand[1:core])
    }
    
    for(i in range){
      clpM <- c()
      clpV <- c()
      for(j in 1:S){
        # p = (b+1)/(m+1)
        clpM[j] <- 2 * min(((sum(c(M[-i,j], M0[j]) < M[i,j]) + 1) / (nRand + 1)), 
                           ((sum(c(M[-i,j], M0[j]) > M[i,j]) + 1) / (nRand + 1)))
        clpV[j] <- 2 * min(((sum(c(V[-i,j], V0[j]) < V[i,j]) + 1) / (nRand + 1)), 
                           ((sum(c(V[-i,j], V0[j]) > V[i,j]) + 1) / (nRand + 1)))
      }
      cldTM <- c(cldTM, (-2 * sum(log(clpM))))
      cldTV <- c(cldTV, (-2 * sum(log(clpV))))
    }
    return(list(dTM = cldTM, dTV = cldTV))
  }
  
  # Send function to cluster
  tmp <- clusterApplyLB(cl, seq(nc), fn, rand = randc, nRand = nRand, M = M, V = V, S = S)
  
  # Distribution of T values.
  dTM <- c()
  dTV <- c()
  
  # Create a vector with results of cluster
  for(i in 1:length(tmp)){
    dTM <- c(dTM, tmp[[i]]$dTM)
    dTV <- c(dTV, tmp[[i]]$dTV)
  }  
  
  # Probability that T observed is drawn from T values generated by the model.
  pvalueM <- sum(dTM > TM0) / (nRand + 1)
  pvalueV <- sum(dTV > TV0) / (nRand + 1)
  
  # Stop Cluster
  stopCluster(cl)
  
  return(list(dTmean = dTM, dTvar = dTV, TMobs = TM0, TVobs = TV0,
              simulations = matrix(c(apply(M, 2, mean), apply(V, 2, mean)), nrow = 2, ncol = S, byrow = TRUE,
                                   dimnames = list(c("mean", "variance"), paste("rank", 1:S, sep = ""))),
              stat = matrix(c(pvalueM, pvalueV), nrow = 2, ncol = 1, 
                          dimnames = list(c("mean", "variance"), "p-value"))))
}
